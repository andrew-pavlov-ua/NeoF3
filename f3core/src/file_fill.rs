// f3core/src/file_fill.rs

use std::{
    fs::File,
    io::{self, ErrorKind, Write},
};

use crate::{
    flow::{DynamicBuffer, Flow},
    utils::{GIB, SECTOR_SIZE, random_number},
};

/// Fill the provided buffer slice in SECTOR_SIZE chunks with a deterministic
/// pseudorandom sequence starting from `offset`.
///
/// Returns the new offset = original offset + number_of_sectors * SECTOR_SIZE.
pub fn fill_buffer(buf: &mut [u8], size: usize, offset: u64) -> u64 {
    let mut current = offset;
    assert!(size > 0, "buffer must not be empty");
    assert!(
        size % SECTOR_SIZE == 0,
        "buffer size must be multiple of SECTOR_SIZE"
    );

    for chunk in buf.chunks_exact_mut(SECTOR_SIZE) {
        let mut prev = current;
        for word in chunk.chunks_exact_mut(8) {
            word.copy_from_slice(&prev.to_ne_bytes());
            prev = random_number(prev);
        }
        current = current.wrapping_add(SECTOR_SIZE as u64);
    }

    current
}

/// Write exactly `*remaining` bytes to `file`, using the internal dynamic buffer.
/// Each write is generated by `fill_buffer`, and `poffset` is updated in place.
///
/// On return, `*remaining` will be zero, and `*poffset` advanced by the total bytes written.
pub fn write_chunk(
    dbuf: &mut DynamicBuffer,
    file: &mut impl Write,
    mut remaining: usize,
    poffset: &mut u64,
) -> io::Result<()> {
    // Ensure our slice is at least `*remaining` long
    let buf = dbuf.get_buf(remaining);
    let buf_len = buf.len();

    while remaining > 0 {
        let turn: usize = buf_len.min(remaining);
        *poffset = fill_buffer(&mut buf[..turn], turn, *poffset);
        file.write_all(&buf[..turn])?;
        remaining -= turn;
    }

    Ok(())
}

/// Internal: for a newly opened file, write out `size` bytes in SECTOR_SIZE chunks.
/// Each chunk is generated by `fill_buffer`. No return value.
pub fn fill_file(file: &mut File, number: i64, size: u64, fw: &mut Flow) -> io::Result<()> {
    let mut dbuf = DynamicBuffer::new();
    let mut offset = number as u64 * GIB;
    let mut remaining = size;

    fw.start_measurement();

    while remaining > 0 {
        let mut chunk_size = fw.get_remaining_chunk_size();
        if chunk_size > remaining {
            chunk_size = remaining;
        }
        if let Err(e) = write_chunk(&mut dbuf, file, chunk_size as usize, &mut offset) {
            if e.raw_os_error() == Some(28) {
                // ENOSPC
                // println!("No space left while writing file: {}.h2w", number);
                return Err(e);
            }
            // Other error
            eprintln!("Error writing chunk: {}", e);
            break;
        }
        remaining -= chunk_size;

        if let Err(e) = fw.measure(file, chunk_size as i64)
            && e.kind() == ErrorKind::Other
            && e.raw_os_error() == Some(28)
        {
            eprintln!("Error during measurement: {}", e);
            return Err(e);
        }
    }
    fw.end_measurement(file)?;

    Ok(())
}
