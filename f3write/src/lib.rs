// f3write/src/lib.rs

use std::{
    fs::{File, OpenOptions},
    io::Result,
    io::{self, ErrorKind, Write},
    process,
    time::Instant,
};

use bytesize::GIB;
use crossterm::{
    cursor::MoveToColumn,
    execute,
    terminal::{Clear, ClearType},
};

use f3core::{
    flow::{DynamicBuffer, Flow},
    utils::{SECTOR_SIZE, adjust_unit, pr_time_str, random_number},
};

#[cfg(windows)]
fn available_bytes_windows(path: &std::path::Path) -> std::io::Result<u64> {
    use std::ffi::OsStr;
    use std::os::windows::ffi::OsStrExt;
    use windows_sys::Win32::Storage::FileSystem::GetDiskFreeSpaceExW;

    let mut avail: u64 = 0;
    let mut total: u64 = 0;
    let mut free: u64 = 0;

    // Path must end with a backslash for root (e.g., "C:\\")
    let mut wide: Vec<u16> = path.as_os_str().encode_wide().chain([0]).collect();
    let ok = unsafe {
        GetDiskFreeSpaceExW(
            wide.as_ptr(),
            &mut avail as *mut u64,
            &mut total as *mut u64,
            &mut free as *mut u64,
        )
    };
    if ok != 0 { Ok(avail) } else { Err(std::io::Error::last_os_error()) }
}

/// Internal helper: query filesystem free space (in bytes) for given path.
#[cfg(unix)]
#[allow(clippy::unnecessary_cast)]
fn get_freespace(path: &str) -> Result<u64> {
    use libc::statvfs;
    use std::ffi::CString;

    let cpath = CString::new(path).expect("CString::new failed");
    let mut s: statvfs = unsafe { std::mem::zeroed() };
    let rc = unsafe { libc::statvfs(cpath.as_ptr(), &mut s) };
    if rc == 0 {
        Ok(s.f_bavail as u64 * s.f_frsize) // bytes available to unprivileged
    } else {
        Err(std::io::Error::last_os_error())
    }
    // stat.blocks_free() * stat.block_size()
}

pub fn print_freespace(path: &str) {
    match get_freespace(path) {
        Ok(free_space) => {
            let (free_space, unit) = adjust_unit(free_space as f64);
            println!("Free space available: {} {}", free_space, unit);
        }
        Err(e) => {
            eprintln!("Error getting free space: {}", e);
        }
    }
}

/// Fill the provided buffer slice in SECTOR_SIZE chunks with a deterministic
/// pseudorandom sequence starting from `offset`.
///
/// Returns the new offset = original offset + number_of_sectors * SECTOR_SIZE.
pub fn fill_buffer(buf: &mut [u8], size: usize, offset: u64) -> u64 {
    let mut current = offset;
    assert!(size > 0, "buffer must not be empty");
    assert!(size % SECTOR_SIZE == 0, "buffer size must be multiple of SECTOR_SIZE");

    for chunk in buf.chunks_exact_mut(SECTOR_SIZE) {
        let mut prev = current;
        for word in chunk.chunks_exact_mut(8) {
            word.copy_from_slice(&prev.to_ne_bytes());
            prev = random_number(prev);
        }
        current = current.wrapping_add(SECTOR_SIZE as u64);
    }

    current
}

/// Write exactly `*remaining` bytes to `file`, using the internal dynamic buffer.
/// Each write is generated by `fill_buffer`, and `poffset` is updated in place.
///
/// On return, `*remaining` will be zero, and `*poffset` advanced by the total bytes written.
pub fn write_chunk(
    dbuf: &mut DynamicBuffer,
    file: &mut impl Write,
    mut remaining: usize,
    poffset: &mut u64,
) -> io::Result<()> {
    // Ensure our slice is at least `*remaining` long
    let buf = dbuf.get_buf(remaining);
    let buf_len = buf.len();

    while remaining > 0 {
        let turn: usize = buf_len.min(remaining);
        *poffset = fill_buffer(&mut buf[..turn], turn, *poffset);
        file.write_all(&buf[..turn])?;
        remaining -= turn;
    }

    Ok(())
}

/// Create (or truncate) the file `<path>/<number>.h2w`, fill it completely
/// (calling `fill_file`), and return `true` if ENOSPC (no space left) was encountered.
pub fn create_and_fill_file(
    path: &str,
    number: i64,
    size: u64,
    _has_suggested_max_write_rate: bool,
    fw: &mut Flow,
) -> Result<()> {
    assert!(size > 0, "Size must be greater than zero");

    let full = format!("{}/{}.h2w", path, number);
    io::stdout().flush().unwrap();

    match OpenOptions::new().create(true).write(true).truncate(true).open(&full) {
        Ok(mut file) => fill_file(&mut file, number, size, fw),
        Err(e) if e.raw_os_error() == Some(28) => {
            // ENOSPC
            println!("No space left.");
            Ok(())
        }
        Err(e) => {
            eprintln!("Error creating file {}: {}", full, e);
            Err(io::Error::other("Error creating file"))
        }
    }
}

/// Internal: for a newly opened file, write out `size` bytes in SECTOR_SIZE chunks.
/// Each chunk is generated by `fill_buffer`. No return value.
fn fill_file(file: &mut File, number: i64, size: u64, fw: &mut Flow) -> io::Result<()> {
    let mut dbuf = DynamicBuffer::new();
    let mut offset = number as u64 * GIB;
    let mut remaining = size;

    fw.start_measurement();
    while remaining > 0 {
        let mut chunk_size = fw.get_remaining_chunk_size();
        if chunk_size > remaining {
            chunk_size = remaining;
        }
        if let Err(e) = write_chunk(&mut dbuf, file, chunk_size as usize, &mut offset) {
            if e.raw_os_error() == Some(28) {
                // ENOSPC
                // println!("No space left while writing file: {}.h2w", number);
                return Err(e);
            }
            // Other error
            eprintln!("Error writing chunk: {}", e);
            break;
        }
        remaining -= chunk_size;

        if let Err(e) = fw.measure(file, chunk_size as i64)
            && e.kind() == ErrorKind::Other
            && e.raw_os_error() == Some(28)
        {
            eprintln!("Error during measurement: {}", e);
            return Err(e);
        }
    }
    fw.end_measurement(file)?;

    Ok(())
}

/// Topâ€level: fill the filesystem at `path` with numbered .h2w files from `start_at`
/// through `*end_at`, respecting available free space and optional rate/progress.
/// Adjusts `*end_at` if free space is smaller than requested file count.
pub fn fill_fs(
    path: &str,
    start_at: i64,
    end_at: &mut i64,
    max_write_rate: i64,
    show_progress: bool,
) -> Result<()> {
    let mut free = get_freespace(path)?;
    if free == 0 {
        eprintln!("Error: no free space available on the device.");
        process::exit(1);
    }

    let count = *end_at - start_at + 1;
    if count > 0 && (count as u64) <= (free >> 30) {
        free = (count as u64) << 30;
    } else {
        *end_at = start_at + (free >> 30) as i64;
    }

    let fs = adjust_unit(free as f64);
    println!("Free space: {} {}", fs.0, fs.1);

    let mut flow = Flow::new(free, max_write_rate, show_progress);

    let start_time = Instant::now();

    for n in start_at..=*end_at {
        let stop = create_and_fill_file(path, n, GIB, show_progress, &mut flow).is_err();

        execute!(io::stdout(), Clear(ClearType::CurrentLine), MoveToColumn(0),).unwrap();

        if stop {
            break;
        }
    }

    // Final report
    println!("--------------------REPORT--------------------");
    print_freespace(path);
    if flow.has_enough_measurements() {
        flow.pr_avg_speed();
    } else {
        let total_time_ms = start_time.elapsed().as_millis() as i64;
        if total_time_ms > 0 {
            flow.pr_avg_speed();
        } else {
            println!("Writing speed not available");
        }
    }

    println!("Total elapsed: {:.2?}", pr_time_str(start_time.elapsed().as_secs_f64()));

    Ok(())
}

#[cfg(test)]
mod write_tests;
